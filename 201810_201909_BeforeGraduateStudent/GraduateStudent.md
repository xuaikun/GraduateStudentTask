# 保研后~研究生开学前的记录

### 2018年11月18日：
开始我的研究生学习，跟师姐做事，听老师的话，好好加油，要发厉害的文章，要拿奖学金，可以为家里省下很多。

### 2018年12月17日：
师姐发了个任务，好好写哦~

## 按周期进行充电

### 2018年12月27日：
实现了按周期充电的方式的构造充电回路
遇到了以前的问题：
while(1):
	x = 1
	print "x = ", x
	for i in range(x, 10):
		print "i =", i
		break
python中运行break后，i 一直= 1

while(1):
	x = 1
	print "x = ", x
	for i in range(x, 10):
		print "i =", i
		continue
continue 还在for内执行，break是跳出for并执行上方与for同级的程序
python中运行continue后，i 每次增加1

### 2019年1月2日：
今天主要完成将离散的点进行连接，并将排序后的点构成一个回路，本次工作主要将数据在二维空间中进行可视化

### 2019年1月3日：
今天主要完成数据范围的确定，不然数据比较乱，不确定，变化范围大。
将A_Star算法中的单位用cm表示，真正输入坐标为m，隐藏一个单位换算的情况。
start_position =[] 
    start_position.append(int(start_position_new[0]*100.0))
    start_position.append(int(start_position_new[1]*100.0))
单位由m转换为cm时，记得乘以100.0不能乘以100，不然数据有可能减小，隐藏着四舍五入的情况。

### 2019年1月4日：
突然发现Numpy在创建10000x10000的二维空间时，电脑内存还能hold得住，二维空间达到50000x50000，果断出现Memory Error的提示，表示电脑内存崩了，Numpy在使用empty创建数组时，创建的数组占用本机内存，所以Numpy.empty([n,n])时，n不能达到50000。也就是说，当我们创建二维空间时，不能太大。

##### 昨天使用在操作网格时，将单位m换成了cm，精度更小了，但是考虑内存问题，还是用单位m来操作比较好。

##### 想法：
将二维空间，化为单位区域（即将二维空间化为网格处理）：化为n个1mx1m的正方形子网格
如果存在障碍，则障碍将占满当前的单位区域
（1）A(1.2,1.5)和B(1.3,1.8)同属于（1，1）区域，在区域中，他们的距离直接使用欧几里得距离计算；
（2）A(1.2,1.5)和B(1.3,1.8)，C（100.1,1000.2），A和B同属于（1,1）区域，C属于（100,10000）区域，A和B到C的距离计算，近似等于区域(2,2)到区域（101,10001）的计算。（用整数部分通过A星算法计算）

##### 至于为什么这样想？
（1）A和B到C的距离是可以证明近似等于区域（2,2）到区域（101,10001）的距离；
（2）当二维空间越大，误差相对来说会越来越小
（3）充电车采取无线充电，覆盖范围应该可以覆盖以半径为0.5m的圆，通常充电车可以采取一对多的方式充电。
（4）通过计算，最大距离误差为1.4m，对于上千m的坐标来说，1.4m的误差是可以被忽略的。

##### 构造哈密尔顿图的方法：
（1）先对电单车当前剩余能量进行排序，按从小到大进行排序标号为1，2，3……，作为A1
（2）记录当前充电车位置到所有电单车的距离（已经充电的，固定了，不再计算它的距离），按从小到大排序，标号为1，2，3……，作为A2
P = a*A1 + b*A2,然后选择P值最小的放在前面构造哈密顿回路。
a、b的值为权重值在（0，1）之间，可以自己调整
此方法兼顾了距离和能耗，每次MCV移动后，所有的距离都会再更新
选择剩余能量最少的，距离MCV近的先服务

##### 距离D作为影响因子
D作为受到区域范围的影响，从而影响充电回路的构造，意思是说：电单车分布的区域范围需要自己调整，作为影响实验的指标。（网络范围），多试几个网络，试试看最大可以达到多大？以往论文中都没做过大规模的，一般都是50到100个节点在小规模范围内。找到一个适合的值，再逐渐往上跳，可以吧做过的数据都记录下来，这样对以后做实验都是一种经验。多试几个网络规模。

### 2019年1月5日：
今天上半天，先把整个程序进行了整理，使其变得更好阅读。
下午发现：
for i in range(1, R_len):
        S点的psum不计算
        psum = psum + P[0][R[i]]
    保留两位小数
    psum = round(psum, 2)
    print "总能耗psum =", psum
    两个决策条件
    factor_1 = round((D*qc*nl)/(vm*(qc*nl-psum)), 2)
    factor_2 = round(((psum*((D*qc)/(vm*(qc*nl-psum)))) + (D*qm)), 2)*
在决策条件中：涉及psum的计算出现了问题：
psum只计算当前加入回路的节点的功率的总和，并不是所有节点的总和，每一次的D和psum都会更新。

### 2019年1月6日：
索引建立邻接矩阵，和直接创建邻接矩阵是不一样的，顺序不一样

#### S位置的选取
充电桩S的位置选取：开始时先不考虑S到各电单车的距离，只是考虑每辆电单车剩余能量，将S放在当前剩余能量最小的电单车旁边。选择剩余能量最少的节点优先服务
#### 对于S的坐标的计算，还得注意不能越界：
S 的坐标比较讲究，不能部署到边界上，
if N_x_new[0][P_i_Max_Node] < edge_n - 1:
    S_x = N_x_new[0][P_i_Max_Node] + 1
else:
    S_x = N_x_new[0][P_i_Max_Node] - 1
    
if N_y_new[0][P_i_Max_Node] < edge_n - 1:
    S_y = N_y_new[0][P_i_Max_Node] + 1
else:
    S_y = N_y_new[0][P_i_Max_Node] - 1
S不能部署到障碍区域内，若发现S的位置在障碍区域内，将S的坐标替换成当前依附的电单车的坐标。这样做可以避免很多计算。

##### 节点是运动和静止的定义
##### 运动：
电单车的能量一直不断消耗，节点的位置在不断发生变化，直到通过节点剩余能量与节点到S的距离，选择它为下一个充电节点后，它的位置才固定（静止）。（实际场景中，这些电单车实际上是在不断运动的），每次MCV要选择下一个充电节点的时候，电单车的位置固定，一旦选择后，被选中过的节点位置固定，其余节点继续运动。

电单车（节点）的方向随机选取（运行过程中只保存这个方向，除非遇到边界，才会改变方向）
电单车运行速度V为5m/s

##### 关于在被选择为下一个充电节点前的坐标的计算（坐标在一直变化）：
假设原来的坐标为：(x, y)
实时变化的坐标为：(x', y')
v  为电单车的运行速度 v = 5m/s
t  为电单车运行的时间 一直变化
alpha 为电单车运动的方向，
alpha = random.randomint(0, 360),
在当前位置，巡视四周（360°），任选一个方向一直运行下去 
##### 新坐标为（x',y'）的计算，已经验证，可行
x' = x + v·t·cos(alpha/180·pi)
y' = y + v·t·sin(alpha/180·pi)

### 2019年1月7日：
对于第一个图：我们可以将所有的节点（电单车）指向充电桩S点
###### 离散点处理scatter参数参考的链接：
https://blog.csdn.net/anneqiqi/article/details/64125186#
###### 途中点的标注annotate
https://blog.csdn.net/leaf_zizi/article/details/82886755
###### 画图中plot的使用方法：
https://blog.csdn.net/cjcrxzz/article/details/79627483
###### 调整图片的大小以及像素等：
https://blog.csdn.net/weixin_34613450/article/details/80678522
###### 图片中线条的粗细和坐标刻度的设置
https://blog.csdn.net/u010358304/article/details/78906768
###### 图片坐标刻度设置
https://blog.csdn.net/hfut_jf/article/details/50755260
###### 添加网格 plt.grid()

为了贴切实际，障碍大小应该达到10mx10m，在网格中将障碍的位置涂绿
应该先放置障碍，然后再生成电单车节点
100平方米区域内不会出现电单车，也没有充电桩，MCV运动时会避开障碍区域

### 2019年1月8日：
将障碍和电单车位置以及充电桩的位置进行关联，先有障碍，然后在布置电单车和充电桩

###### 图例的放置位置：
https://blog.csdn.net/qq_33221533/article/details/81431264

还得考虑个问题，就是电单车运行过程中，依然要判断自己是否遇到障碍，如果遇到则改变运动方向
如果不进行处理，程序会崩溃，因为你要找的电单车在障碍区域内，MVC无法到达，所以就错了~

###### 关于电单车放置的地方，要在建筑物外围至少+1m的地方

### 2019年1月9日：
##### 关于电单车运动过程中遇到障碍的处理：
##### 目前是这么想的：计算A-->B的距离
第一、计算没有障碍物的空间中A-->B的距离d1，以作参考
第二、计算有障碍物空间中A-->B的距离d2，同时判断B在不在障碍区域内
如果B在障碍区域内，直接修改B的坐标，即：改变当前电单车的运动方向，
如果B不在障碍区域内，判断d1 == d2：
如果相等，则当前电单车不需要改变方向，如果不相等，则需要改变当前电单车的运动方向

### 2019年1月10日：
##### A_star算法还要修改：
不能经过一个节点就直接永久把它置为障碍：
而是分为两种障碍：
（1）对于本阶段的永久障碍：perpetual_obstacle
（2）对于本阶段的暂时障碍:temp_obstacle
经过一个节点，先把它设置成temp_obstacle
如果当前节点，4面被障碍环绕，则这个这个位置变成perpetual_obstacle
同时将temp_obstacle全部释成可遍历的二维空间
（3）还有个重要的情况：如果f = g + h 的值一直不变，表示运动的节点很有可能回到起点，
所以需要有一个判断，当目前的运动点运动回到起点，则释放所有的临时障碍，变为可以遍历的
空间
###### 电单车节点和S节点的位置：
随机生成电单车节点，S节点就在功率最大的节点的坐标，且都不存在障碍区域内，并且一定在障碍外围至少+1m处

###### 程序运行流程还需要改进：
（1）（先操作有障碍的空间）应该先判断当前终点B是否在障碍里面，确定终点B不在障碍区域内了，在计算距离障碍空间中A-->B的距离d1
（2）（再操作无障碍空间，这样就可以省下很多时间）计算无障碍空间中A-->B的距离d2
（3）比较d1和d2的值，相等，则表明这就是B能在这个位置，这就是A的当前阶段的终点，否则需要变向，B的坐标将会改变

###### 现阶段的两个任务：
（1）将充电子回路呈现在图表中，服务站S以及其依附的节点，还有各节点的重新编号，以及各种连线（已经实现）
（2）将A_Star算法加快运行~（已解决~）

### 2019年1月11日：
###### 任务：
将A_Star算法加速运行:
之前初始化数组使用：
x = np.empty([n, n], int)
但是用np.empty产生的数组不是非常明确，需要人工初始化，如：
for i in range(0, n):
	for j in range(0, n):
	x[i][j] = 1
因为np.empty需要在内存中操作，大大减缓运行速度
n = 2000 时，大概需要4s才能完成初始化
###### 解决方法：（A_Star算法提速完成）
使用x = np.zeros((n, n), dtype = np.int)
或者x = np.oners((n, n), dtype = np.int)
来初始化全0或全1矩阵（python底层使用c/c++操作）
几乎不需要花时间
大概 0.05s左右，速度提升80倍左右

### 2019年1月12日：
###### 发现一个问题：
就是在之前A_Star算法中，如果当前点进入一个死胡同，如果死胡同够长，下次它还会进死胡同，只是比上一次少走一个单位
###### 解决方法：
如果进入的是死胡同，当前点设置为障碍后，还得判断下一个点是否还在死胡同里，如果在，再把这个点设置为障碍，以此类推就能把整个死胡同用障碍填满，之后运行就不用进去了，大大缩短运行时间。

###### 目前有一个问题：
发现如果只有一个服务站S时，还有很多电单车并没有被充电，这个时候我们应该通过添加服务站S的数量来解决这个问题。因为测试数据得到一些结果表明，在space = 200mx200m中，
我们一个服务站S就能服务所有的电单车，但是在space = 1000mx1000m的空间中，我们发现，
一个服务站S只能服务一部分的电单车，而且只是少数的电单车，这与我们的设计不符合，因为大多数电单车没有被服务，意思是说我们放弃了大多数电单车充电的机会。
##### 解决方法：
重复之前的方法，在添加服务站S就行呢

### 2019年1月13日：
跑了几组数据，发现图形比较诡异，应该得修改

### 2019年1月14日：
要测试多S的情况：
50个节点，200x200的空间，多个S画图

###### 发现两个不同的影响因素：
（1）首先是节点数量->直接影响整个程序的运行所需时间，为什么这么说呢？主要是涉及矩阵
的构建，矩阵构建前，要做的事主要是节点运动后，每个节点的坐标会改变，改变之前又有很多判断（主要是因为节点的终点，不能存在于障碍中或者从起始点到终点之间，存在障碍，所以这些点需要重新改变运动方向），所以呢，节点数量直接影响程序运行所需时间。
（2）然后是二维空间的大小->直接影响充电子回路的构造，因为二维空间的距离太大了，导致很多点到S的距离大大增加，因此无法满足可调度性判断的决策，所以呢，存在蛮多点无法参与构造充电子回路，所以平面中出现很多死亡的电单车。

### 2019年1月15日：
###### 解决的问题是：
基于一个S的情况下，不是所有点都满足充电决策条件，导致很多点都会被饿死，所以需要部署多个S，以便解决在所有节点还存活的充电情况下，生成更多的充电子回路。达到S最少的设计。并且呈现在图表中。

### 2019年1月16日：
###### 有些小问题：
（1）节点的颜色即使被连线颜色修改了，后面也得修改回来（最后再来个恢复颜色就行)
(解决)
（2）坐标系刻度问题，不在乎是否太过于精确，能表明那就是坐标就行，避免出现奇奇怪怪的坐标终点，坐标不能重叠，间距大一点（已解决）
（3）在5->10个节点之间，实现一种动态显示的效果，初始化的状态运动到构建哈密顿回路，在一张图上表示，最好显示出动态的效果。（已经解决）

### 2019年1月17日：：
###### 接下来要做的事情：
（1）MCV给充电节点充电，是需要时间的哦，->此处需要知道:MVC的充电效率，节点的剩余的能量，->获取当前MCV给节点充了多少能量，从而结算充电花了多长时间time
->MCV移动到某个节点后，需要为这个节点充满电后再选择下一个节点进行服务
->相较于MCV运动过程中所耗的电量而言，充电的电量要少很多
->这里需要解决充电效率的问题
->需要知道，MCV用于充电的电量与MCV用于移动的电量
->在为当前节点充电的时候，其他节点都在运动，其能量都在不断地减少
->MCV移动到这个点，为这个点充满电
->只有实现这一步，我们才可以做充电效率，充电效率是需要知道MCV用于移动消耗了多少能量，用于给节点充电消耗了多少能量
->还需要统计一下回路的路径长度
->如果不考虑充电过程，在大规模节点中很有可能就没有系欸但死亡的
->但是我们有个实验是要做一下节点死亡率
->需要知道MCV的耗能主要有两个方面：（1）移动耗能（2）充电耗能
->先画好5个点的图
（2）MCV走整个回路的所需时间，->此处需要是知道：整个回路的长度

完成这两个问题后，就可以向按需充电发展了~
###### 解决思路：
（1）不需要单独构建哈密顿回路了，构建哈密顿回路就是为了找充电次序，在构建哈密顿回路过程中，已经根据剩余能量和距离选择完次序了，所以在构建回路过程中我们就应该考虑耗电过程
（2）MCV先在网络中根据距离能量选择需要第一个充电的节点，然后判断这个节点是否满足可调度性条件，如果满足就过去，如果不满足，则选择另一个节点继续判断。（按P进行排序）
（3）第二步，确定一个节点可以服务后，MCV过去为它充电，充满电后判断剩余节点中哪个需要先服务，不满足就再次选择别的节点，这个过程中其它节点不断运动，耗能
（4）师姐的问题，一个点a到另一个点b，途中遇到障碍，能不能模拟a——>b的真实路径？
（5）如果剩余的点都不满足可调度性条件，则构建新的回路，如果某个节点不能加入当前S的任一个充电子回路，则重新创建S。
（6）突然想明白的问题：一个点距离远但是能量实在少，那么它的优先级肯定也高，选择距离没那么远，剩余能量没那么少的完全可以，再次选择剩余能量少距离近的点
（7）某个节点由当前S服务不合理，总是不可调度，说明它应该由别的服务站服务
（8）只有MCV准备选择下一个点服务了，题目在那个时候位置才是固定的。（确定后，其他点依旧运动）

###### 我的理解有问题：P = axEs + bxDistance
###### 更正理解：其中a = 0.2 b = 0.8  
Es表示每个节点剩余能量的从小到大排序的序号，Distance表示S到各节点的距离从小到大排序的序号
P为每个节点的综合排名

### 2019年1月18日：
###### 今天的任务，先把a->b真实路径模拟出来
### 2019年1月19日：
###### 路径算模拟出来，还得进一步处理，将凌晨最后一次结果给师姐，好像效果不错哟
###### 自己理解的问题：P = axEs + bxDistance 
其中的Distance是MCV到接下来未操作的点的距离，并不是服务站S到节点未操作的点的距离

##### python中numpy文件的一些操作，以及一下参数的设计链接：https://www.cnblogs.com/wushaogui/p/9142019.html

### 2019年1月20日：
今天主要是测数据了哟，
先把50、100、150、200、250个点跑一下
只要50个点需要一张构建成回路的图

主要把100个节点做全，其他数量的点做一组数据用于对照就行了

### 2019年1月21日：
 把程序发给师姐自己跑了~，我电脑hold不住

### 2019年1月22日：
写好汇报ppt 

### 2019年1月23日：
出发长沙

### 2019年1月24日：
与师兄师姐们做汇报

## 按需充电实验要准备开始啦~~~

### 2019年1月30日：
#### 在按需充电实验中第一步要做的是：求出两个阈值Et和El
（1）当电单车节点Es < Et时，电单车节点发送Request给MCV，需要一个缓冲区（数组）保存发送了Request的电
单车节点的标号
（2）当电单车节点Es < El时，电单车节点发送ALERT给MCV,表明电单车此时已经不能再运动，变成了静态节点，与
此同时MCV将为电单车节点进行充电（所充电的节点的标号，已经保存到缓冲区里面了）
#### 对于阈值的计算：
（1）Et是一个固定值，作为阈值上限，当电单车节点Es < Et时，开始向MCV发送Request信号
（2）El是一个需要计算的值，作为阈值下限，当电单车节点Es < El时，开始向MCV发送AlERT信号
##### El的计算方法：
##### 单位时间内电单车(强调单位时间内)
平均能量消耗-average every consumption rate(AECR)
平均电单车失效率(失效：完全没有电量)-average failure probability(AFP)
AECR(El) = A1xEl + B1
可以找出多对单位时间内(El, AECR)的值，比如(0.1, 0.027),(0.14, 0.029),(0.18, 0.031)
因此说在单位时间内，通过变化El的值，可以获得对应的AECR的值，将一对对(El, AECR)通过直线相连，可以获得
AECR(El) = A1xEl + B1直线的方程式，从而可以获得对应的A1、B1
从而令El_average = average(El),获得AECR(El)的平均值AECR

AFP(El) = A2xEl + B2
可以找出多对单位时间内(El, AFP)的值，比如(0.1, 0.5),(0.14, 0.45),(0.18, 0.3)
因此说在单位时间内，通过变化El的值，可以获得对应的AFP的值，将一对对(El, AFP)通过直线相连，可以获得
AFP(El) = A2xEl + B2直线方程式，从而可以获得对应的A2、B2
从而令El_average = average(El),获得AFP(El)的平均值AFP

##### AECR 为平均值，从AECR(El)这条直线中取出的平均值
##### AFP 为平均值，从AFP(El)这条直线中取出的平均值
所以很容易获得A1、B1、A2、B2

f(w) = (AECR)x(AECR) + wx(AFP)x(AFP)
求f(w)目的是想获得最好的w
El(w) = (A1xB1 + wxA2xB2)/((A1)x(A1) + wx(A2)x(A2))
以获得最优El

#### 对于平均能量消耗AECR和平均电单车失效率AFP的理解：
AECR：因为对应El不同，单位时间内整个系统的电单车能量消耗是不一样的，所以会有平均值
(能量消耗的总和/总时间)
AFP：因为对应El不同，单位时间内整个系统的电单车失效率是不一样的，所以会有平均值
(失效电单车数量的总和/电单车数量)

### 2019年1月31日：
将昨天的算法进行实现，其实总的还好，感觉也不是特别的难，主要是现在需要将某段时间内平均能耗以及电单车失效率计算出来。

### 2019年2月26日：
过了个年回来，感觉浪费了好多时间，今天把按需充电的第二种出发机制的流程图给画了，还不知道对还是错，不过有几个问题得注意：
(1)关于El的范围计算，可能会超过Et，超过Et，El = Et - 100
El < 0时， El = 100，可以在第一次运行时（运行200s左右），可以看到电单车节点发送了ALERT信息给MCV，现象比较正常
(2)决策条件中Vm的计算还存在问题，记得提醒师姐告诉我。
(3)选择插入算法，我的实现方式是，在选中下一个服务节点时，先从ALERT缓冲池中找另一个形成角度在90~180°的点进行插入回路，如不满足条件，则从request缓冲池中找另一个形成角度在90~180°的点进行插入，待定？
总体来说，看到结果还是挺正常的

### 2019年2月27日：
师弟，我觉得可以第一种充电机制可以直接改为设置时长t,这个t是动态变化的，t应该是和MCV移动速度是相关的
可以做实验来观察
MCV在就等待t时长
然后出发为接收到的节点服务
这样其实也相当于任务缓冲池是动态变化的
你觉得可以吗？（不可取）

### 2019年2月28日：
关于对比实验，接收到Request信息，直接为其充电，存在依次充电，我们可以利用功率的大小来决定，初始节点的能量是一样的，
功率不一样，在相同的时间里，消耗的能量也是不同的
Et是固定的值，只要节点剩余能量小于等于Et时，节点就会向MCV发送Request信息，MCV就会过去给该节点充电，以达到一接收
Request信息就被充电，用初始能量-Et就是节点所要消耗的能量，根据每个节点的功率，计算得到每个节点将要消耗的时间，根据
时间大小进行排序，先从消耗时间小的开始添加入充电回路，直到消耗时间最大的节点。
不完全是这么想，因为还要考虑距离问题，MCV运动的距离需要用于计算时间，充电时间归充电时间，总之得好好想一下
##### 解决思路：
假设开始时每个节点运动的时间是相同的，但是有一些节点运动到半路就停下来了，因此所需时间是不一样的
在时间段内，检查缓冲池中收到Request的数量(对应节点，并确定节点运动到下一位置所需时间，
用时少的先服务)

###### 你在做完这两个之后，先做任务缓冲池为固定值的情况下的实验

### 2019年3月1日：
按需充电的第二种出发机制已经完成：
记录一些实验过程中遇到的问题：
(1)涉及到xxx率的时候，一定记得它的值一定小于等于1，大于等于0
(2)循环求解El(w)时，w的值基本稳定在200以内【设定w>1,这是一个权重问题，侧重点不一样】，w
的求解存在精度问题，精度目前是0.01，可以自己调整
(3)测试El时，El从0到Et变化，其中涉及一个步长问题，步长的大小会影响AECR(El)和AFP(El),
最终影响El(w)的稳定。
(4)El稳定的时候并不一定是正值，我感觉取它绝对值即可【论文中的公式前面有负号，师姐写的公
式前面没有负号，综合考虑取绝对值即可】

### 2019年3月2日：
我觉得服务站S的位置刚开始的时候并不是确定的，只知道它首次是依附着Node1创建，所以等到Node1需要充电时，停下来的地方
也就是S的部署地方。

在相同数据的情况下，前后两次回路数据不一样的

##### 解决在相同数据执行的前提下，出现结果不相同的问题：
主要是每个节点的使用频率的倒数，没有进行备份保存，导致使用备份数据的时候，产生节点的使用频率为随机数，所以导致
产生实验结果不相同，
##### 在选择最佳节点的三元组判断公式中，存在两个较小值则优先充电

#### 关于选择插入算法，隐含处在电单车直接从其它两边走了，在三角形中存在两边之和大于第三边，但是当那两边之间的夹角
y存在 90° < y < 270°时，两边之和近似等于第三边，直接默认插入节点时，满足可调度性条件

#### 写按需充电的第一种出发机制

### 2019年3月3日：
对于死亡节点的处理，首先从剩余能量可以发现，当剩余能量小于等于0j时，该节点就是死亡节点，但是仍然可以将其加入充电回路，有一种解释：死亡只是没电，可以再次
充电后继续使用。
##### 一大注意的点：画图中，考虑黑白打印的问题，尽量不要用相同的线条仅改变颜色，不然到
时候打印出来的图中线条都是相同的(一定得注意哦)

### 2019年3月4日：
凌晨跑40节点数据的时候，程序出现错误，通过计算AlphaValue的取值范围应该在(1.14°~11.4°)，之前的取值为AlphaValue = 30°，有点不太合适，导致程序出现死循环
的情况，目前已经将AlphaValue = 5了，目前程序没有出现死循环的情况
晚上应该进行下面的实验了以时间为横轴，统计几种情况下各种量的变化，
以程序结束为终止点，期间可以间隔适合的时间长度

### 2019年3月5日：
第一种出发机实验中没有统计到死亡节点的个数，原因：在第二种出发机制中我们动态调整了El的值，El又是全局变量，在第一种出发机制的对比实验中要有需要El = 0才
能统计出死亡节点的个数

节点平均服务时间：节点的充电请求被移动充电车响应直到该节点被移动充电车服务完成的时间间隔
平均响应时间：节点发送充电请求到被移动充电车响应的时间间隔，也就是充电时延

### 2019年3月6日：
要明白全局变量和局部变量的区别

### 2019年3月7日：
将第二种出发机制的仿真时间与两种性能的关系搞清楚
【固定缓冲池】【双阈值】【单阈值】实验已解决

### 2019年3月8日：
今日任务NJNP算法的实现
NJNP算法已经实现
今日需要实现TADP算法
TADP算法已经实现
今日需要完成RCSS算法
RCSS算法已经实现

##### 明天开始完成回路分配算法

### 2019年3月9日:
似乎程序中又发现了bug，得好好检查一下

### 2019年3月10日：
python中Copy数据的情况，浅copy和深copy的区别，不然在数组操作的时候很容易出错
https://blog.csdn.net/AManFromEarth/article/details/80931737

第一种出发机制的实验

### 2019年3月11日：
算已经完成实验，接下来就是测试数据了
先把50个节点的数据测试出来，看看有没有什么不妥，如果没有不妥的，就可以开始测试比较大的数据了

### 2019年3月12日：
改进第二种出发机制，主要是关于死亡节点的定义：剩余能量低于0J时，为死亡节点，即使发送了ALERT，也得等选择下一最佳服务点是它时，才能停止运行或者能量剩余为0J，也停止运行
并学习画热力图，如果没什么问题，明天就可以测试数据了

### 2019n年3月13日：
画热力图~
好的，那就把固定任务缓冲池大小的实验的固定缓冲池大小设置6，8，10，12
分别跑这几个值看看

### 2019年3月14日：
师弟，你下来跑40，60，80，100，120的前四个实验，让实验先跑着，就是第一种还有第一种比较，第二种和第二种比较
固定缓冲池大小设置为10
最小缓冲池设置的是4
热力图完成了！
