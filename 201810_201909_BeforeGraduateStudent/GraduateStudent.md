# 保研后~研究生开学前的记录

### 2018年11月18日：
开始我的研究生学习，跟师姐做事，听老师的话，好好加油，要发厉害的文章，要拿奖学金，可以为家里省下很多。

### 2018年12月17日：
师姐发了个任务，好好写哦~

## 按周期进行充电

### 2018年12月27日：
实现了按周期充电的方式的构造充电回路
遇到了以前的问题：
while(1):
	x = 1
	print "x = ", x
	for i in range(x, 10):
		print "i =", i
		break
python中运行break后，i 一直= 1

while(1):
	x = 1
	print "x = ", x
	for i in range(x, 10):
		print "i =", i
		continue
continue 还在for内执行，break是跳出for并执行上方与for同级的程序
python中运行continue后，i 每次增加1

### 2019年1月2日：
今天主要完成将离散的点进行连接，并将排序后的点构成一个回路，本次工作主要将数据在二维空间中进行可视化

### 2019年1月3日：
今天主要完成数据范围的确定，不然数据比较乱，不确定，变化范围大。
将A_Star算法中的单位用cm表示，真正输入坐标为m，隐藏一个单位换算的情况。
start_position =[] 
    start_position.append(int(start_position_new[0]*100.0))
    start_position.append(int(start_position_new[1]*100.0))
单位由m转换为cm时，记得乘以100.0不能乘以100，不然数据有可能减小，隐藏着四舍五入的情况。

### 2019年1月4日：
突然发现Numpy在创建10000x10000的二维空间时，电脑内存还能hold得住，二维空间达到50000x50000，果断出现Memory Error的提示，表示电脑内存崩了，Numpy在使用empty创建数组时，创建的数组占用本机内存，所以Numpy.empty([n,n])时，n不能达到50000。也就是说，当我们创建二维空间时，不能太大。

##### 昨天使用在操作网格时，将单位m换成了cm，精度更小了，但是考虑内存问题，还是用单位m来操作比较好。

##### 想法：
将二维空间，化为单位区域（即将二维空间化为网格处理）：化为n个1mx1m的正方形子网格
如果存在障碍，则障碍将占满当前的单位区域
（1）A(1.2,1.5)和B(1.3,1.8)同属于（1，1）区域，在区域中，他们的距离直接使用欧几里得距离计算；
（2）A(1.2,1.5)和B(1.3,1.8)，C（100.1,1000.2），A和B同属于（1,1）区域，C属于（100,10000）区域，A和B到C的距离计算，近似等于区域(2,2)到区域（101,10001）的计算。（用整数部分通过A星算法计算）

##### 至于为什么这样想？
（1）A和B到C的距离是可以证明近似等于区域（2,2）到区域（101,10001）的距离；
（2）当二维空间越大，误差相对来说会越来越小
（3）充电车采取无线充电，覆盖范围应该可以覆盖以半径为0.5m的圆，通常充电车可以采取一对多的方式充电。
（4）通过计算，最大距离误差为1.4m，对于上千m的坐标来说，1.4m的误差是可以被忽略的。

##### 构造哈密尔顿图的方法：
（1）先对电单车当前剩余能量进行排序，按从小到大进行排序标号为1，2，3……，作为A1
（2）记录当前充电车位置到所有电单车的距离（已经充电的，固定了，不再计算它的距离），按从小到大排序，标号为1，2，3……，作为A2
P = a*A1 + b*A2,然后选择P值最小的放在前面构造哈密顿回路。
a、b的值为权重值在（0，1）之间，可以自己调整
此方法兼顾了距离和能耗，每次MCV移动后，所有的距离都会再更新
选择剩余能量最少的，距离MCV近的先服务

##### 距离D作为影响因子
D作为受到区域范围的影响，从而影响充电回路的构造，意思是说：电单车分布的区域范围需要自己调整，作为影响实验的指标。（网络范围），多试几个网络，试试看最大可以达到多大？以往论文中都没做过大规模的，一般都是50到100个节点在小规模范围内。找到一个适合的值，再逐渐往上跳，可以吧做过的数据都记录下来，这样对以后做实验都是一种经验。多试几个网络规模。

### 2019年1月5日：
今天上半天，先把整个程序进行了整理，使其变得更好阅读。
下午发现：
for i in range(1, R_len):
        S点的psum不计算
        psum = psum + P[0][R[i]]
    保留两位小数
    psum = round(psum, 2)
    print "总能耗psum =", psum
    两个决策条件
    factor_1 = round((D*qc*nl)/(vm*(qc*nl-psum)), 2)
    factor_2 = round(((psum*((D*qc)/(vm*(qc*nl-psum)))) + (D*qm)), 2)*
在决策条件中：涉及psum的计算出现了问题：
psum只计算当前加入回路的节点的功率的总和，并不是所有节点的总和，每一次的D和psum都会更新。

### 2019年1月6日：
索引建立邻接矩阵，和直接创建邻接矩阵是不一样的，顺序不一样

#### S位置的选取
充电桩S的位置选取：开始时先不考虑S到各电单车的距离，只是考虑每辆电单车剩余能量，将S放在当前剩余能量最小的电单车旁边。选择剩余能量最少的节点优先服务
#### 对于S的坐标的计算，还得注意不能越界：
S 的坐标比较讲究，不能部署到边界上，
if N_x_new[0][P_i_Max_Node] < edge_n - 1:
    S_x = N_x_new[0][P_i_Max_Node] + 1
else:
    S_x = N_x_new[0][P_i_Max_Node] - 1
    
if N_y_new[0][P_i_Max_Node] < edge_n - 1:
    S_y = N_y_new[0][P_i_Max_Node] + 1
else:
    S_y = N_y_new[0][P_i_Max_Node] - 1
S不能部署到障碍区域内，若发现S的位置在障碍区域内，将S的坐标替换成当前依附的电单车的坐标。这样做可以避免很多计算。

##### 节点是运动和静止的定义
##### 运动：
电单车的能量一直不断消耗，节点的位置在不断发生变化，直到通过节点剩余能量与节点到S的距离，选择它为下一个充电节点后，它的位置才固定（静止）。（实际场景中，这些电单车实际上是在不断运动的），每次MCV要选择下一个充电节点的时候，电单车的位置固定，一旦选择后，被选中过的节点位置固定，其余节点继续运动。

电单车（节点）的方向随机选取（运行过程中只保存这个方向，除非遇到边界，才会改变方向）
电单车运行速度V为5m/s

##### 关于在被选择为下一个充电节点前的坐标的计算（坐标在一直变化）：
假设原来的坐标为：(x, y)
实时变化的坐标为：(x', y')
v  为电单车的运行速度 v = 5m/s
t  为电单车运行的时间 一直变化
alpha 为电单车运动的方向，
alpha = random.randomint(0, 360),
在当前位置，巡视四周（360°），任选一个方向一直运行下去 
##### 新坐标为（x',y'）的计算，已经验证，可行
x' = x + v·t·cos(alpha/180·pi)
y' = y + v·t·sin(alpha/180·pi)

### 2019年1月7日：
对于第一个图：我们可以将所有的节点（电单车）指向充电桩S点
###### 离散点处理scatter参数参考的链接：
https://blog.csdn.net/anneqiqi/article/details/64125186#
###### 途中点的标注annotate
https://blog.csdn.net/leaf_zizi/article/details/82886755
###### 画图中plot的使用方法：
https://blog.csdn.net/cjcrxzz/article/details/79627483
###### 调整图片的大小以及像素等：
https://blog.csdn.net/weixin_34613450/article/details/80678522
###### 图片中线条的粗细和坐标刻度的设置
https://blog.csdn.net/u010358304/article/details/78906768
###### 图片坐标刻度设置
https://blog.csdn.net/hfut_jf/article/details/50755260
###### 添加网格 plt.grid()

为了贴切实际，障碍大小应该达到10mx10m，在网格中将障碍的位置涂绿
应该先放置障碍，然后再生成电单车节点
100平方米区域内不会出现电单车，也没有充电桩，MCV运动时会避开障碍区域

### 2019年1月8日：
将障碍和电单车位置以及充电桩的位置进行关联，先有障碍，然后在布置电单车和充电桩

###### 图例的放置位置：
https://blog.csdn.net/qq_33221533/article/details/81431264

还得考虑个问题，就是电单车运行过程中，依然要判断自己是否遇到障碍，如果遇到则改变运动方向
如果不进行处理，程序会崩溃，因为你要找的电单车在障碍区域内，MVC无法到达，所以就错了~

###### 关于电单车放置的地方，要在建筑物外围至少+1m的地方

### 2019年1月9日：
##### 关于电单车运动过程中遇到障碍的处理：
##### 目前是这么想的：计算A-->B的距离
第一、计算没有障碍物的空间中A-->B的距离d1，以作参考
第二、计算有障碍物空间中A-->B的距离d2，同时判断B在不在障碍区域内
如果B在障碍区域内，直接修改B的坐标，即：改变当前电单车的运动方向，
如果B不在障碍区域内，判断d1 == d2：
如果相等，则当前电单车不需要改变方向，如果不相等，则需要改变当前电单车的运动方向

### 2019年1月10日：
##### A_star算法还要修改：
不能经过一个节点就直接永久把它置为障碍：
而是分为两种障碍：
（1）对于本阶段的永久障碍：perpetual_obstacle
（2）对于本阶段的暂时障碍:temp_obstacle
经过一个节点，先把它设置成temp_obstacle
如果当前节点，4面被障碍环绕，则这个这个位置变成perpetual_obstacle
同时将temp_obstacle全部释成可遍历的二维空间
（3）还有个重要的情况：如果f = g + h 的值一直不变，表示运动的节点很有可能回到起点，
所以需要有一个判断，当目前的运动点运动回到起点，则释放所有的临时障碍，变为可以遍历的
空间
###### 电单车节点和S节点的位置：
随机生成电单车节点，S节点就在功率最大的节点的坐标，且都不存在障碍区域内，并且一定在障碍外围至少+1m处

###### 程序运行流程还需要改进：
（1）（先操作有障碍的空间）应该先判断当前终点B是否在障碍里面，确定终点B不在障碍区域内了，在计算距离障碍空间中A-->B的距离d1
（2）（再操作无障碍空间，这样就可以省下很多时间）计算无障碍空间中A-->B的距离d2
（3）比较d1和d2的值，相等，则表明这就是B能在这个位置，这就是A的当前阶段的终点，否则需要变向，B的坐标将会改变

###### 现阶段的两个任务：
（1）将充电子回路呈现在图表中，服务站S以及其依附的节点，还有各节点的重新编号，以及各种连线（已经实现）
（2）将A_Star算法加快运行~（已解决~）

### 2019年1月11日：
###### 任务：
将A_Star算法加速运行:
之前初始化数组使用：
x = np.empty([n, n], int)
但是用np.empty产生的数组不是非常明确，需要人工初始化，如：
for i in range(0, n):
	for j in range(0, n):
	x[i][j] = 1
因为np.empty需要在内存中操作，大大减缓运行速度
n = 2000 时，大概需要4s才能完成初始化
###### 解决方法：（A_Star算法提速完成）
使用x = np.zeros((n, n), dtype = np.int)
或者x = np.oners((n, n), dtype = np.int)
来初始化全0或全1矩阵（python底层使用c/c++操作）
几乎不需要花时间
大概 0.05s左右，速度提升80倍左右

### 2019年1月12日：
###### 发现一个问题：
就是在之前A_Star算法中，如果当前点进入一个死胡同，如果死胡同够长，下次它还会进死胡同，只是比上一次少走一个单位
###### 解决方法：
如果进入的是死胡同，当前点设置为障碍后，还得判断下一个点是否还在死胡同里，如果在，再把这个点设置为障碍，以此类推就能把整个死胡同用障碍填满，之后运行就不用进去了，大大缩短运行时间。

###### 目前有一个问题：
发现如果只有一个服务站S时，还有很多电单车并没有被充电，这个时候我们应该通过添加服务站S的数量来解决这个问题。因为测试数据得到一些结果表明，在space = 200mx200m中，
我们一个服务站S就能服务所有的电单车，但是在space = 1000mx1000m的空间中，我们发现，
一个服务站S只能服务一部分的电单车，而且只是少数的电单车，这与我们的设计不符合，因为大多数电单车没有被服务，意思是说我们放弃了大多数电单车充电的机会。
##### 解决方法：
重复之前的方法，在添加服务站S就行呢

### 2019年1月13日：
跑了几组数据，发现图形比较诡异，应该得修改

### 2019年1月14日：
要测试多S的情况：
50个节点，200x200的空间，多个S画图

###### 发现两个不同的影响因素：
（1）首先是节点数量->直接影响整个程序的运行所需时间，为什么这么说呢？主要是涉及矩阵
的构建，矩阵构建前，要做的事主要是节点运动后，每个节点的坐标会改变，改变之前又有很多判断（主要是因为节点的终点，不能存在于障碍中或者从起始点到终点之间，存在障碍，所以这些点需要重新改变运动方向），所以呢，节点数量直接影响程序运行所需时间。
（2）然后是二维空间的大小->直接影响充电子回路的构造，因为二维空间的距离太大了，导致很多点到S的距离大大增加，因此无法满足可调度性判断的决策，所以呢，存在蛮多点无法参与构造充电子回路，所以平面中出现很多死亡的电单车。

### 2019年1月15日：
###### 解决的问题是：
基于一个S的情况下，不是所有点都满足充电决策条件，导致很多点都会被饿死，所以需要部署多个S，以便解决在所有节点还存活的充电情况下，生成更多的充电子回路。达到S最少的设计。并且呈现在图表中。

### 2019年1月16日：
###### 有些小问题：
（1）节点的颜色即使被连线颜色修改了，后面也得修改回来（最后再来个恢复颜色就行)
(解决)
（2）坐标系刻度问题，不在乎是否太过于精确，能表明那就是坐标就行，避免出现奇奇怪怪的坐标终点，坐标不能重叠，间距大一点（已解决）
（3）在5->10个节点之间，实现一种动态显示的效果，初始化的状态运动到构建哈密顿回路，在一张图上表示，最好显示出动态的效果。（已经解决）

### 2019年1月17日：：
###### 接下来要做的事情：
（1）MCV给充电节点充电，是需要时间的哦，->此处需要知道:MVC的充电效率，节点的剩余的能量，->获取当前MCV给节点充了多少能量，从而结算充电花了多长时间time
->MCV移动到某个节点后，需要为这个节点充满电后再选择下一个节点进行服务
->相较于MCV运动过程中所耗的电量而言，充电的电量要少很多
->这里需要解决充电效率的问题
->需要知道，MCV用于充电的电量与MCV用于移动的电量
->在为当前节点充电的时候，其他节点都在运动，其能量都在不断地减少
->MCV移动到这个点，为这个点充满电
->只有实现这一步，我们才可以做充电效率，充电效率是需要知道MCV用于移动消耗了多少能量，用于给节点充电消耗了多少能量
->还需要统计一下回路的路径长度
->如果不考虑充电过程，在大规模节点中很有可能就没有系欸但死亡的
->但是我们有个实验是要做一下节点死亡率
->需要知道MCV的耗能主要有两个方面：（1）移动耗能（2）充电耗能
->先画好5个点的图
（2）MCV走整个回路的所需时间，->此处需要是知道：整个回路的长度

完成这两个问题后，就可以向按需充电发展了~
###### 解决思路：
（1）不需要单独构建哈密顿回路了，构建哈密顿回路就是为了找充电次序，在构建哈密顿回路过程中，已经根据剩余能量和距离选择完次序了，所以在构建回路过程中我们就应该考虑耗电过程
（2）MCV先在网络中根据距离能量选择需要第一个充电的节点，然后判断这个节点是否满足可调度性条件，如果满足就过去，如果不满足，则选择另一个节点继续判断。（按P进行排序）
（3）第二步，确定一个节点可以服务后，MCV过去为它充电，充满电后判断剩余节点中哪个需要先服务，不满足就再次选择别的节点，这个过程中其它节点不断运动，耗能
（4）师姐的问题，一个点a到另一个点b，途中遇到障碍，能不能模拟a——>b的真实路径？
（5）如果剩余的点都不满足可调度性条件，则构建新的回路，如果某个节点不能加入当前S的任一个充电子回路，则重新创建S。
（6）突然想明白的问题：一个点距离远但是能量实在少，那么它的优先级肯定也高，选择距离没那么远，剩余能量没那么少的完全可以，再次选择剩余能量少距离近的点
（7）某个节点由当前S服务不合理，总是不可调度，说明它应该由别的服务站服务
（8）只有MCV准备选择下一个点服务了，题目在那个时候位置才是固定的。（确定后，其他点依旧运动）

###### 我的理解有问题：P = axEs + bxDistance
###### 更正理解：其中a = 0.2 b = 0.8  
Es表示每个节点剩余能量的从小到大排序的序号，Distance表示S到各节点的距离从小到大排序的序号
P为每个节点的综合排名

### 2019年1月18日：
###### 今天的任务，先把a->b真实路径模拟出来
### 2019年1月19日：
###### 路径算模拟出来，还得进一步处理，将凌晨最后一次结果给师姐，好像效果不错哟
###### 自己理解的问题：P = axEs + bxDistance 
其中的Distance是MCV到接下来未操作的点的距离，并不是服务站S到节点未操作的点的距离

##### python中numpy文件的一些操作，以及一下参数的设计链接：https://www.cnblogs.com/wushaogui/p/9142019.html

### 2019年1月20日：
今天主要是测数据了哟，
先把50、100、150、200、250个点跑一下
只要50个点需要一张构建成回路的图

主要把100个节点做全，其他数量的点做一组数据用于对照就行了
