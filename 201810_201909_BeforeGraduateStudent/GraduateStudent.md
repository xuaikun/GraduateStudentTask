# 保研后~研究生开学前的记录

### 2018年11月18日：
开始我的研究生学习，跟师姐做事，听老师的话，好好加油，要发厉害的文章，要拿奖学金，可以为家里省下很多。

### 2018年12月17日：
师姐发了个任务，好好写哦~

## 按周期进行充电

### 2018年12月27日：
实现了按周期充电的方式的构造充电回路
遇到了以前的问题：
while(1):
	x = 1
	print "x = ", x
	for i in range(x, 10):
		print "i =", i
		break
python中运行break后，i 一直= 1

while(1):
	x = 1
	print "x = ", x
	for i in range(x, 10):
		print "i =", i
		continue
continue 还在for内执行，break是跳出for并执行上方与for同级的程序
python中运行continue后，i 每次增加1

### 2019年1月2日：
今天主要完成将离散的点进行连接，并将排序后的点构成一个回路，本次工作主要将数据在二维空间中进行可视化

### 2019年1月3日：
今天主要完成数据范围的确定，不然数据比较乱，不确定，变化范围大。
将A_Star算法中的单位用cm表示，真正输入坐标为m，隐藏一个单位换算的情况。
start_position =[] 
    start_position.append(int(start_position_new[0]*100.0))
    start_position.append(int(start_position_new[1]*100.0))
单位由m转换为cm时，记得乘以100.0不能乘以100，不然数据有可能减小，隐藏着四舍五入的情况。

### 2019年1月4日：
突然发现Numpy在创建10000x10000的二维空间时，电脑内存还能hold得住，二维空间达到50000x50000，果断出现Memory Error的提示，表示电脑内存崩了，Numpy在使用empty创建数组时，创建的数组占用本机内存，所以Numpy.empty([n,n])时，n不能达到50000。也就是说，当我们创建二维空间时，不能太大。

##### 昨天使用在操作网格时，将单位m换成了cm，精度更小了，但是考虑内存问题，还是用单位m来操作比较好。

##### 想法：
将二维空间，化为单位区域（即将二维空间化为网格处理）：化为n个1mx1m的正方形子网格
如果存在障碍，则障碍将占满当前的单位区域
（1）A(1.2,1.5)和B(1.3,1.8)同属于（1，1）区域，在区域中，他们的距离直接使用欧几里得距离计算；
（2）A(1.2,1.5)和B(1.3,1.8)，C（100.1,1000.2），A和B同属于（1,1）区域，C属于（100,10000）区域，A和B到C的距离计算，近似等于区域(2,2)到区域（101,10001）的计算。（用整数部分通过A星算法计算）

##### 至于为什么这样想？
（1）A和B到C的距离是可以证明近似等于区域（2,2）到区域（101,10001）的距离；
（2）当二维空间越大，误差相对来说会越来越小
（3）充电车采取无线充电，覆盖范围应该可以覆盖以半径为0.5m的圆，通常充电车可以采取一对多的方式充电。
（4）通过计算，最大距离误差为1.4m，对于上千m的坐标来说，1.4m的误差是可以被忽略的。

##### 构造哈密尔顿图的方法：
（1）先对电单车当前剩余能量进行排序，按从小到大进行排序标号为1，2，3……，作为A1
（2）记录当前充电车位置到所有电单车的距离（已经充电的，固定了，不再计算它的距离），按从小到大排序，标号为1，2，3……，作为A2
P = a*A1 + b*A2,然后选择P值最小的放在前面构造哈密顿回路。
a、b的值为权重值在（0，1）之间，可以自己调整
此方法兼顾了距离和能耗，每次MCV移动后，所有的距离都会再更新
选择剩余能量最少的，距离MCV近的先服务

##### 距离D作为影响因子
D作为受到区域范围的影响，从而影响充电回路的构造，意思是说：电单车分布的区域范围需要自己调整，作为影响实验的指标。（网络范围），多试几个网络，试试看最大可以达到多大？以往论文中都没做过大规模的，一般都是50到100个节点在小规模范围内。找到一个适合的值，再逐渐往上跳，可以吧做过的数据都记录下来，这样对以后做实验都是一种经验。多试几个网络规模。

### 2019年1月5日：
今天上半天，先把整个程序进行了整理，使其变得更好阅读。
下午发现：
for i in range(1, R_len):
        S点的psum不计算
        psum = psum + P[0][R[i]]
    保留两位小数
    psum = round(psum, 2)
    print "总能耗psum =", psum
    两个决策条件
    factor_1 = round((D*qc*nl)/(vm*(qc*nl-psum)), 2)
    factor_2 = round(((psum*((D*qc)/(vm*(qc*nl-psum)))) + (D*qm)), 2)*
在决策条件中：涉及psum的计算出现了问题：
psum只计算当前加入回路的节点的功率的总和，并不是所有节点的总和，每一次的D和psum都会更新。

### 2019年1月6日：
索引建立邻接矩阵，和直接创建邻接矩阵是不一样的，顺序不一样

#### S位置的选取
充电桩S的位置选取：开始时先不考虑S到各电单车的距离，只是考虑每辆电单车剩余能量，将S放在当前剩余能量最小的电单车旁边。选择剩余能量最少的节点优先服务

##### 节点是运动和静止的定义
##### 运动：
电单车的能量一直不断消耗，节点的位置在不断发生变化，直到通过节点剩余能量与节点到S的距离，选择它为下一个充电节点后，它的位置才固定（静止）。（实际场景中，这些电单车实际上是在不断运动的），每次MCV要选择下一个充电节点的时候，电单车的位置固定，一旦选择后，被选中过的节点位置固定，其余节点继续运动。

电单车（节点）的方向随机选取（运行过程中只保存这个方向，除非遇到边界，才会改变方向）
电单车运行速度V为5m/s

##### 关于在被选择为下一个充电节点前的坐标的计算（左边在一直变化）：
假设原来的坐标为：(x, y)
实时变化的坐标为：(x', y')
v  为电单车的运行速度 v = 5m/s
t  为电单车运行的时间 一直变化
alpha 为电单车运动的方向，
alpha = random.randomint(0, 360),
在当前位置，巡视四周（360°），任选一个方向一直运行下去 
##### 新坐标为（x',y'）的计算，已经验证，可行
x' = x + v·t·cos(alpha/180·pi)
y' = y + v·t·sin(alpha/180·pi)